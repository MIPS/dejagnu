/* DejaGnu unit testing header.
   Copyright (C) 2000-2016, 2022 Free Software Foundation, Inc.

This file is part of DejaGnu.

DejaGnu is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.

DejaGnu is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with DejaGnu; if not, write to the Free Software Foundation,
Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */

#ifndef __DEJAGNU_H__
#define __DEJAGNU_H__

#include <stdio.h>
#include <stdarg.h>
#include <string.h>

/* If you have problems with DejaGnu dropping failed, untested, or
 * unresolved messages generated by a unit testcase, then see the section
 * "Priority of Expect Patterns" in *note (dejagnu)Writing a test case. or
 * use the DejaGnu built-in unit testing support in your testsuite, which
 * has been improved to resolve this issue in DejaGnu 1.6.3.  */

static struct {
  int pass;
  int fail;
  int xpass;
  int xfail;
  int untested;
  int unresolved;
  int unsupported;
} DG__status = { 0 };

static inline void
pass (const char* fmt, ...)
{
  va_list ap;

  DG__status.pass++;

  flockfile (stdout);
  fputs ("\tPASSED: ", stdout);
  va_start (ap, fmt); vfprintf (stdout, fmt, ap); va_end (ap);
  fputc ('\n', stdout);
  funlockfile (stdout);
}

static inline void
xpass (const char* fmt, ...)
{
  va_list ap;

  DG__status.xpass++;

  flockfile (stdout);
  fputs ("\tXPASSED: ", stdout);
  va_start (ap, fmt); vfprintf (stdout, fmt, ap); va_end (ap);
  fputc ('\n', stdout);
  funlockfile (stdout);
}

static inline void
fail (const char* fmt, ...)
{
  va_list ap;

  DG__status.fail++;

  flockfile (stdout);
  fputs ("\tFAILED: ", stdout);
  va_start (ap, fmt); vfprintf (stdout, fmt, ap); va_end (ap);
  fputc ('\n', stdout);
  funlockfile (stdout);
}

static inline void
xfail (const char* fmt, ...)
{
  va_list ap;

  DG__status.xfail++;

  flockfile (stdout);
  fputs ("\tXFAILED: ", stdout);
  va_start (ap, fmt); vfprintf (stdout, fmt, ap); va_end (ap);
  fputc ('\n', stdout);
  funlockfile (stdout);
}

static inline void
untested (const char* fmt, ...)
{
  va_list ap;

  DG__status.untested++;

  flockfile (stdout);
  fputs ("\tUNTESTED: ", stdout);
  va_start (ap, fmt); vfprintf (stdout, fmt, ap); va_end (ap);
  fputc ('\n', stdout);
  funlockfile (stdout);
}

static inline void
unresolved (const char* fmt, ...)
{
  va_list ap;

  DG__status.unresolved++;

  flockfile (stdout);
  fputs ("\tUNRESOLVED: ", stdout);
  va_start (ap, fmt); vfprintf (stdout, fmt, ap); va_end (ap);
  fputc ('\n', stdout);
  funlockfile (stdout);
}

static inline void
unsupported (const char* fmt, ...)
{
  va_list ap;

  DG__status.unsupported++;

  flockfile (stdout);
  fputs ("\tUNSUPPORTED: ", stdout);
  va_start (ap, fmt); vfprintf (stdout, fmt, ap); va_end (ap);
  fputc ('\n', stdout);
  funlockfile (stdout);
}

static inline void
note (const char* fmt, ...)
{
  va_list ap;

  flockfile (stdout);
  fputs ("\tNOTE: ", stdout);
  va_start (ap, fmt); vfprintf (stdout, fmt, ap); va_end (ap);
  fputc ('\n', stdout);
  funlockfile (stdout);
}

static inline void
totals (void)
{
  printf ("\nTotals:\n");
  printf ("\t#passed:\t\t%d\n", DG__status.pass);
  printf ("\t#real failed:\t\t%d\n", DG__status.fail);
  if (DG__status.xfail)
    printf ("\t#expected failures:\t\t%d\n", DG__status.xfail);
  if (DG__status.xpass)
    printf ("\t#unexpected passes:\t\t%d\n", DG__status.xpass);
  if (DG__status.untested)
    printf ("\t#untested:\t\t%d\n", DG__status.untested);
  if (DG__status.unresolved)
    printf ("\t#unresolved:\t\t%d\n", DG__status.unresolved);
  if (DG__status.unsupported)
    printf ("\t#unsupported:\t\t%d\n", DG__status.unsupported);
  printf ("\tEND: done\n");
}

#ifdef __cplusplus

#include <iostream>
#include <iomanip>
#include <fstream>
#include <string>

const char *outstate_list[] = {
  "FAILED: ", "PASSED: ",
  "UNTESTED: ", "UNRESOLVED: ", "UNSUPPORTED: ",
  "XFAILED: ", "XPASSED: "
};

const char ** outstate = outstate_list;

enum teststate { FAILED, PASSED,
		 UNTESTED, UNRESOLVED, UNSUPPORTED,
		 XFAILED, XPASSED } laststate;

class TestState {
 private:
  teststate laststate;
  std::string lastmsg;
 public:
  TestState (void)
    {
      DG__status.pass = 0;
      DG__status.fail = 0;
      DG__status.untested = 0;
      DG__status.xpass = 0;
      DG__status.xfail = 0;
      DG__status.unresolved = 0;
      DG__status.unsupported = 0;
    }

  ~TestState (void) { totals(); }

  void testrun (bool b, std::string s)
    {
      if (b)
	pass (s);
      else
	fail (s);
    }

    void pass (std::string s)
      {
	DG__status.pass++;
	laststate = PASSED;
	lastmsg = s;
	std::cout << "\t" << outstate[PASSED] << s << std::endl;
      }

    void xpass (std::string s)
      {
	DG__status.xpass++;
	laststate = PASSED;
	lastmsg = s;
	std::cout << "\t" << outstate[XPASSED] << s << std::endl;
      }

    void fail (std::string s)
      {
	DG__status.fail++;
	laststate = FAILED;
	lastmsg = s;
	std::cout << "\t" << outstate[FAILED] << s << std::endl;
      }

    void xfail (std::string s)
      {
	DG__status.xfail++;
	laststate = XFAILED;
	lastmsg = s;
	std::cout << "\t" << outstate[XFAILED] << s << std::endl;
      }

    void untested (std::string s)
      {
	DG__status.untested++;
	laststate = UNTESTED;
	lastmsg = s;
	std::cout << "\t" << outstate[UNTESTED] << s << std::endl;
      }

    void unresolved (std::string s)
      {
	DG__status.unresolved++;
	laststate = UNRESOLVED;
	lastmsg = s;
	std::cout << "\t" << outstate[UNRESOLVED] << s << std::endl;
      }

    void unsupported (std::string s)
      {
	DG__status.unsupported++;
	laststate = UNSUPPORTED;
	lastmsg = s;
	std::cout << "\t" << outstate[UNSUPPORTED] << s << std::endl;
      }

    void note (std::string s)
      {
	std::cout << "\t" << "NOTE: " << s << std::endl;
      }

    void totals (void)
      {
	std::cout << std::endl << "Totals:" << std::endl;

	std::cout << "\t#passed:\t\t"
		  << DG__status.pass << std::endl;
	std::cout << "\t#real failed:\t\t"
		  << DG__status.fail << std::endl;

	if (DG__status.xfail)
	  std::cout << "\t#expected failures:\t\t"
		    << DG__status.xfail << std::endl;
	if (DG__status.xpass)
	  std::cout << "\t#unexpected passes:\t\t"
		    << DG__status.xpass << std::endl;
	if (DG__status.untested)
	  std::cout << "\t#untested:\t\t"
		    << DG__status.untested << std::endl;
	if (DG__status.unresolved)
	  std::cout << "\t#unresolved:\t\t"
		    << DG__status.unresolved << std::endl;
	if (DG__status.unsupported)
	  std::cout << "\t#unsupported:\t\t"
		    << DG__status.unsupported << std::endl;

	std::cout << "\tEND: done" << std::endl;
      }

    // This is so this class can be printed in an ostream.
    friend std::ostream & operator << (std::ostream &os, TestState& t)
      {
	return os << "\t" << outstate[t.laststate] << t.lastmsg ;
      }

    int GetState (void) { return laststate; }
    std::string GetMsg (void) { return lastmsg; }
};

#endif /* __cplusplus */
#endif /* _DEJAGNU_H_ */
